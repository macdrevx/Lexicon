{"entries":[{"id":0,"name":"abstraction pattern","definition":"\n  The unsubstituted generic type of a property or function parameter, which\n  sets constraints on its representation in memory. For example, given the\n  following definitions::\n\n    struct Foo<T> {\n      var value: T\n      \/\/ Foo.value has abstraction pattern <T> T\n\n    struct Bar<T, U> {\n      var value: (T) -> U\n      \/\/ Bar.value has abstraction pattern <T, U> (T) -> U\n    }\n    struct Bas {\n      var value: (Int) -> String\n      \/\/ Bas.value has abstraction pattern (Int) -> String\n    }\n    let transform: (Int) -> String = { \"\\($0)\" }\n    let foo = Foo<(Int) -> String>(value: transform)\n    let bar = Bar<Int, String>(value: transform)\n    let bas = Bas(value: transform)\n\n  although ``foo.value``, ``bar.value``, and ``bas.value`` all have the same\n  function type ``(Int) -> String``, they have different *abstraction\n  patterns*. Because a value of type ``Foo`` or ``Bar`` may be used in a\n  generic context and invoke ``value`` with a parameter or result type\n  of unknown size, the compiler has to pick a more conservative representation\n  for the closure that uses indirect argument passing, whereas ``Bas.value``\n  has a fully concrete closure type so can always use a more specialized\n  direct register-based calling convention. The compiler transparently\n  introduces `reabstraction` conversions when a value is used with a\n  different abstraction pattern. (This is where the infamous \"reabstraction\n  thunk helpers\" sometimes seen in Swift backtraces come from.)"},{"id":1,"name":"archetype","definition":"\n  A placeholder for a generic parameter or an associated type within a\n  generic context. Sometimes known as a \"rigid type variable\" in formal\n  CS literature. Directly stores its conforming protocols and nested\n  archetypes, if any."},{"id":2,"name":"AST","definition":"\n  \"Abstract syntax tree\", although in practice it's more of a directed graph.\n  A parsed representation of code used by a compiler."},{"id":3,"name":"bitcode","definition":"\n  Serialized LLVM `IR`."},{"id":4,"name":"build czar","definition":"\n  Apple term for \"the person assigned to watch CI this week\"."},{"id":5,"name":"canonical SIL","definition":"\n  SIL after the\n  `mandatory passes <mandatory passes \/ mandatory optimizations>` have run.\n  This can be used as input to IRGen to generate LLVM IR or object files."},{"id":6,"name":"canonical type","definition":"\n  A unique representation of a type, with any `sugar <sugared type>` removed.\n  These can usually be directly compared to test whether two types are the\n  same; the exception is when generics get involved. In this case you'll need\n  a `generic environment`. Contrast with `sugared type`."},{"id":7,"name":"Clang importer","definition":"\n  The part of the compiler that reads C and Objective-C declarations and\n  exposes them as Swift. Essentially contains a small instance of Clang\n  running inside the Swift compiler, which is also used during IRGen."},{"id":8,"name":"conformance","definition":"\n  A construct detailing how a particular type conforms to a particular\n  protocol. Represented in the compiler by the ProtocolConformance type at\n  the AST level. See also `witness table`."},{"id":9,"name":"contextual type","definition":"\n  1. The expected type for a Swift sub-expression based on the rest of the\n     statement. For example, in the statement ``print(6 * 9)``, the contextual\n     type of the expression ``6 * 9`` is ``Any``.\n  2. The type of a value or declaration from inside a potentially generic\n     context. This type may contain `archetypes <archetype>` and cannot be\n     used directly from outside the context. Compare with `interface type`."},{"id":10,"name":"DI (definite initialization \/ definitive initialization)","definition":"\n  The feature that no uninitialized variables, constants, or properties will\n  be read by a program, or the analysis pass that operates on SIL to\n  guarantee this. This was `discussed on Apple's Swift blog`__.\n\n  __ https:\/\/developer.apple.com\/swift\/blog\/?id=28"},{"id":11,"name":"dup","definition":"\n  From \"duplicate\". As a noun, refers to another filed issue that describes\n  the same bug (\"I have a dup of this\"); as a verb, the act of marking a bug\n  *as* a duplicate (\"Please dup this to the underlying issue\"). Sometimes\n  written \"dupe\". Pronounced the same way as the first syllable of\n  \"duplicate\", which for most American English speakers is \"doop\"."},{"id":12,"name":"existential","definition":"\n  A value whose type is a protocol composition (including a single protocol\n  and *zero* protocols; the latter is the ``Any`` type)."},{"id":13,"name":"fragile","definition":"\n  Describes a type or function where making changes will break binary\n  compatibility. See :doc:`LibraryEvolution.rst <LibraryEvolution>`."},{"id":14,"name":"generic environment","definition":"\n  Provides context for interpreting a type that may have generic parameters\n  in it. Generic parameter types are normally just represented as \"first\n  generic parameter in the outermost context\" (or similar), so it's up to the\n  generic environment to note that that type must be a Collection. (Another\n  way of looking at it is that the generic environment connects\n  `interface types <interface type>` with\n  `contextual types <contextual type>`)."},{"id":15,"name":"generic signature","definition":"\n  A representation of all generic parameters and their requirements. Like\n  types, generic signatures can be `canonicalized <canonical type>` to be\n  compared directly."},{"id":16,"name":"iff","definition":"\n  \"`if and only if`__\". This term comes from mathematics.\n\n  __ https:\/\/en.wikipedia.org\/wiki\/If_and_only_if"},{"id":17,"name":"interface type","definition":"\n  The type of a value or declaration outside its generic context. These types\n  are written using \"formal\" generic types, which only have meaning when\n  combined with a particular generic declaration's \"generic signature\".\n  Unlike `contextual types <contextual type>`, interface types store\n  conformances and requirements in the generic signature and not in the types\n  themselves. They can be compared across declarations but cannot be used\n  directly from within the context."},{"id":18,"name":"irrefutable pattern","definition":"\n  A pattern that always matches. These patterns either bind to a variable or\n  perform structural modification, e.x.:\n\n  1. ``case _:``.\n  2. ``case let x:``.\n  3. ``case (_, _):``."},{"id":19,"name":"IR","definition":"\n  1. \"intermediate representation\": a generic term for a format representing\n     code in a way that is easy for a compiler or tool to manipulate.\n  2. \"LLVM IR\": a particular IR used by the LLVM libraries for optimization\n     and generation of machine code."},{"id":20,"name":"IUO (implicitly unwrapped optional)","definition":"\n  A type like Optional, but it implicitly converts to its wrapped type. If\n  the value is ``nil`` during such a conversion, the program traps just as\n  it would when a normal Optional is force-unwrapped. IUOs implicitly\n  convert to and from normal Optionals with the same wrapped type."},{"id":21,"name":"IWYU (include what you use)","definition":"\n  The accepted wisdom that implementation files (``.cpp``, ``.c``, ``.m``,\n  ``.mm``) should explicitly ``#include`` or ``#import`` the headers they use.\n  Doing so prevents compilation errors when header files are included in a\n  different order, or when header files are modified to use forward\n  declarations instead of direct includes."},{"id":22,"name":"LGTM","definition":"\n  \"Looks good to me.\" Used in code review to indicate approval with no further\n  comments."},{"id":23,"name":"LLVM IR","definition":"\n  See `IR`."},{"id":24,"name":"lvalue","definition":"\n  Pronounced \"L-value\". Refers to an expression that can be assigned to or\n  passed ``inout``. The term originally comes from C; the \"L\" refers to the\n  \"l\"eft side of an assignment operator. See also `rvalue`."},{"id":25,"name":"main module","definition":"\n  The module for the file or files currently being compiled."},{"id":26,"name":"mandatory passes \/ mandatory optimizations","definition":"\n  Transformations over SIL that run immediately after SIL generation. Once\n  all mandatory passes have run (and if no errors are found), the SIL is\n  considered `canonical <canonical SIL>`."},{"id":27,"name":"metatype","definition":"\n  The type of a value representing a type. Greg Parker has a good\n  explanation of `Objective-C's \"metaclasses\"`__; because Swift has types\n  that are *not* classes, a more general term is used.\n\n  We also sometimes refer to a value representing a type as a \"metatype\n  object\" or just \"metatype\", usually within low-level contexts like IRGen\n  and LLDB. This is technically incorrect (it's just a \"type object\"), but\n  the malapropism happened early in the project and has stuck around.\n\n  __ http:\/\/sealiesoftware.com\/blog\/archive\/2009\/04\/14\/objc_explain_Classes_and_metaclasses.html"},{"id":28,"name":"model","definition":"\n  A type that conforms to a particular protocol. Sometimes \"concrete\n  model\". Example: \"Array and Set are both models of CollectionType\"."},{"id":29,"name":"module","definition":"\n  Has *many* uses in the Swift world. We may want to rename some of them.\n  #1 and #2 are the most common.\n\n  1. A unit of API distribution and grouping. The ``import`` declaration\n     brings modules into scope. Represented as ModuleDecl in the compiler.\n  2. A compilation unit; that is, source files that are compiled together.\n     These files may contain cross-references. Represented as \"the main\n     module\" (a specific ModuleDecl).\n  3. (as \"SIL module\") A container for SIL to be compiled together, along\n     with various context for the compilation.\n  4. (as \"LLVM module\") A collection of LLVM IR to be compiled together.\n     Always created in an LLVMContext.\n  5. A file containing serialized AST and SIL information for a source file\n     or entire compilation unit. Often \"swiftmodule file\", with \"swiftmodule\"\n     pronounced as a single word.\n  6. (as \"Clang module\") A set of self-contained C-family header files.\n     Represented by a ClangModuleUnit in the Swift compiler, each of which is\n     contained in its own ModuleDecl. For more information, see\n     `Clang's documentation for Modules`__.\n  7. Shorthand for a \"precompiled module file\"; effectively \"precompiled\n     headers\" for an entire Clang module. Never used directly by Swift.\n     See also `module cache`.\n\n  __ http:\/\/clang.llvm.org\/docs\/Modules.html"},{"id":30,"name":"module cache","definition":"\n  Clang's cache directory for precompiled module files. As cache files, these\n  are not forward-compatible, and so cannot be loaded by different versions\n  of Clang (or programs using Clang, like the Swift compiler). Normally this\n  is fine, but occasionally a development compiler will not have proper\n  version information and may try to load older module files, resulting in\n  crashes in ``clang::ASTReader``."},{"id":31,"name":"NFC","definition":"\n  \"No functionality change.\" Written in commit messages that are intended to\n  have no change on the compiler or library's behavior, though for some this\n  refers to having the *same* implementation and for others merely an\n  *equivalent* one.  \"NFC\" is typically used to explain why a patch has no\n  included testcase, since the Swift project requires testcases for all\n  patches that change functionality."},{"id":32,"name":"open existential","definition":"\n  An `existential` value with its dynamic type pulled out, so that the\n  compiler can do something with it."},{"id":33,"name":"overlay","definition":"\n  A library that is imported whenever a C library or framework by the same\n  name is imported. The purpose of an overlay is to augment and extend a\n  library on the system when the library on the system cannot be modified.\n  Apple has a number of overlays for its own SDKs in stdlib\/public\/SDK\/."},{"id":34,"name":"PCH","definition":"\n  Precompiled header, a type of file ending in .pch. A precompiled header is\n  like a precompiled module, in the sense that it's the same file format and\n  is just a cache file produced by clang and read by ``clang::ASTReader``. The\n  difference is that PCH files are not \"modular\": they do not correspond to a\n  named module, and cannot be read in any order or imported by module-name;\n  rather they must be the first file parsed by the compiler. PCHs are used\n  only to accelerate the process of reading C\/C++\/Objective-C headers, such as\n  the bridging headers read in by the ``-import-objc-header`` command-line\n  flag to swiftc."},{"id":35,"name":"PR","definition":"\n  1. \"Problem Report\": An issue reported in `LLVM's bug tracker`__.\n     See also `SR`.\n  2. \"pull request\"\n\n  __ https:\/\/llvm.org\/bugs\/"},{"id":36,"name":"primary file","definition":"\n  The file currently being compiled, as opposed to the other files that are\n  only needed for context. See also\n  `Whole-Module Optimization <WMO (whole-module optimization)>`."},{"id":37,"name":"QoI","definition":"\n  \"Quality of implementation.\" The term is meant to describe not how\n  well-engineered a particular implementation is, but how much value it\n  provides to users beyond a sort of minimum expectation. Good diagnostics\n  are a matter of QoI, as is good unoptimized performance. For example, a\n  comment like \"FIXME: QoI could be improved here\" is suggesting that there's\n  some sort of non-mandatory work that could be done that would improve the\n  behavior of the compiler--it is not just a general statement that the code\n  needs to be improved.\n\n  It's possible that this term was originally \"quality of life\", written as\n  \"Qol\", referring to the experience of end users. At some point along its\n  history, the lowercase \"L\" was misinterpreted as an uppercase \"i\", and a\n  new meaning derived. Swift inherited this term from LLVM, which got it from\n  GCC."},{"id":38,"name":"Radar","definition":"\n  `Apple's bug-tracking system`__, or an issue reported on that system.\n\n  __ https:\/\/bugreport.apple.com"},{"id":39,"name":"raw SIL","definition":"\n  SIL just after being generated, not yet in a form that can be used for\n  IR generation.\n  See `mandatory passes <mandatory passes \/ mandatory optimizations>`."},{"id":40,"name":"reabstraction","definition":"\n  An implicit representation change that occurs when a value is used with\n  a different `abstraction pattern` from its current representation."},{"id":41,"name":"refutable pattern","definition":"\n  A pattern that may not always match. These include patterns such as:\n\n  1. Isa check, e.g. ``case let x as String:``.\n  2. Enum case check: e.g. ``case .none:``.\n  3. Expr pattern: e.g. ``case foo():``."},{"id":42,"name":"resilient","definition":"\n  Describes a type or function where making certain changes will not break\n  binary compatibility. See :doc:`LibraryEvolution.rst <LibraryEvolution>`."},{"id":43,"name":"runtime","definition":"\n  Code that implements a language's dynamic features that aren't just\n  compiled down to plain instructions. For example, Swift's runtime library\n  includes support for dynamic casting and for the Mirror-based reflection."},{"id":44,"name":"rvalue","definition":"\n  Pronounced \"R-value\". Represents an expression that can be used as a value;\n  in Swift this is nearly every expression, so we don't use the term very\n  often. The term originally comes from C; the \"R\" refers to the \"r\"ight side\n  of an assignment operator. Contrast with `lvalue`."},{"id":45,"name":"script mode","definition":"\n  The parsing mode that allows top-level imperative code in a source file."},{"id":46,"name":"SIL","definition":"\n  \"Swift Intermediate Language\". A high-level IR used by the Swift compiler\n  for flow-sensitive diagnostics, optimization, and LLVM IR generation.\n\n-sil-serialize-all\n  A mode where all functions in a library are made available for inlining by\n  any client, regardless of access control. Also called \"magic performance\n  mode\" as a reminder of how this drastically changes compilation. Not\n  guaranteed to work on arbitrary code."},{"id":47,"name":"SR","definition":"\n  An issue reported on `bugs.swift.org <https:\/\/bugs.swift.org>`_. A\n  backronym for \"Swift Report\"; really the name is derived from LLVM's\n  idiomatic use of \"PR\" (\"Problem Report\") for its bugs. We didn't go with\n  \"PR\" for Swift because we wanted to be able to unambiguously reference\n  LLVM bugs."},{"id":48,"name":"stdlib","definition":"\n  \"Standard library\". Sometimes this just means the \"Swift\" module (also\n  known as \"swiftCore\"); sometimes it means everything in the stdlib\/\n  directory. Pronounced \"stid-lib\" or \"ess-tee-dee-lib\"."},{"id":49,"name":"sugared type","definition":"\n  A type that may have been written in a more convenient way, using special\n  language syntax or a typealias. (For example, ``Int?`` is the sugared form\n  of ``Optional<Int>``.) Sugared types preserve information about the form\n  and use of the type even though the behavior usually does not change\n  (except for things like access control). Contrast with `canonical type`."},{"id":50,"name":"thunk","definition":"\n  In the Swift compiler, a synthesized function whose only purpose is to\n  perform some kind of adjustment in order to call another function. For\n  example, Objective-C and Swift have different calling conventions, so the\n  Swift compiler generates a thunk for use in Objective-C that calls through\n  to the real Swift implementation."},{"id":51,"name":"trap","definition":"\n  A deterministic runtime failure. Can be used as both as a noun (\"Using an\n  out-of-bounds index on an Array results in a trap\") and a verb\n  (\"Force-unwrapping a nil Optional will trap\")."},{"id":52,"name":"type metadata","definition":"\n  The runtime representation of a type, and everything you can do with it.\n  Like a ``Class`` in Objective-C, but for any type."},{"id":53,"name":"USR","definition":"\n  A Unified Symbol Resolution (USR) is a string that identifies a particular\n  entity (function, class, variable, etc.) within a program. USRs can be\n  compared across translation units to determine, e.g., when references in\n  one translation refer to an entity defined in another translation unit."},{"id":54,"name":"value witness table","definition":"\n  A runtime structure that describes how to do basic operations on an unknown\n  value, like \"assign\", \"copy\", and \"destroy\". (For example, does copying\n  this value require any retains?)\n\n  Only conceptually related to a `witness table`."},{"id":55,"name":"vtable (virtual dispatch table)","definition":"\n  A map attached to a class of which implementation to use for each\n  overridable method in the class. Unlike an Objective-C method table,\n  vtable keys are just offsets, making lookup much simpler at the cost of\n  dynamism and duplicated information about *non*-overridden methods."},{"id":56,"name":"witness","definition":"\n  The value or type that satisfies a protocol requirement."},{"id":57,"name":"witness table","definition":"\n  The SIL (and runtime) representation of a `conformance`; essentially a\n  `vtable <vtable (virtual dispatch table)>` but for a protocol instead of\n  a class.\n\n  Only conceptually related to a `value witness table`."},{"id":58,"name":"WMO (whole-module optimization)","definition":"\n  A compilation mode where all files in a module are compiled in a single\n  process. In this mode there is no `primary file`; all files are parsed,\n  type-checked, and optimized together at the SIL level. LLVM optimization\n  and object file generation may happen all together or in separate threads."}]}
